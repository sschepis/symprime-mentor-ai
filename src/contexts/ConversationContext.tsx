import { createContext, useContext, useState, ReactNode, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useUser } from "./UserContext";
import { toast } from "sonner";

export interface Message {
  id: string;
  conversation_id: string;
  role: "user" | "assistant";
  content: string;
  created_at: string;
}

export interface Conversation {
  id: string;
  user_id: string;
  engine_id?: string;
  title: string;
  created_at: string;
  updated_at: string;
}

interface ConversationContextType {
  conversations: Conversation[];
  currentConversation: Conversation | null;
  messages: Message[];
  isLoading: boolean;
  createConversation: (title: string, engineId?: string) => Promise<Conversation | null>;
  selectConversation: (id: string) => Promise<void>;
  sendMessage: (content: string) => Promise<void>;
  deleteConversation: (id: string) => Promise<void>;
  clearMessages: () => Promise<void>;
  refreshConversations: () => Promise<void>;
}

const ConversationContext = createContext<ConversationContextType | undefined>(undefined);

export const ConversationProvider = ({ children }: { children: ReactNode }) => {
  const [conversations, setConversations] = useState<Conversation[]>([]);
  const [currentConversation, setCurrentConversation] = useState<Conversation | null>(null);
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const { session, isAuthenticated } = useUser();

  const fetchConversations = async () => {
    if (!session?.user?.id) return;

    try {
      const { data, error } = await supabase
        .from("conversations")
        .select("*")
        .eq("user_id", session.user.id)
        .order("updated_at", { ascending: false });

      if (error) throw error;

      setConversations(data || []);
    } catch (error) {
      console.error("Error fetching conversations:", error);
      toast.error("Failed to load conversations");
    } finally {
      setIsLoading(false);
    }
  };

  const fetchMessages = async (conversationId: string) => {
    try {
      const { data, error } = await supabase
        .from("messages")
        .select("*")
        .eq("conversation_id", conversationId)
        .order("created_at", { ascending: true });

      if (error) throw error;

      setMessages((data || []) as Message[]);
    } catch (error) {
      console.error("Error fetching messages:", error);
      toast.error("Failed to load messages");
    }
  };

  useEffect(() => {
    if (isAuthenticated) {
      fetchConversations();
    } else {
      setConversations([]);
      setCurrentConversation(null);
      setMessages([]);
      setIsLoading(false);
    }
  }, [isAuthenticated, session?.user?.id]);

  const createConversation = async (title: string, engineId?: string): Promise<Conversation | null> => {
    if (!session?.user?.id) return null;

    try {
      const { data, error } = await supabase
        .from("conversations")
        .insert([
          {
            user_id: session.user.id,
            title,
            engine_id: engineId,
          },
        ])
        .select()
        .single();

      if (error) throw error;

      setConversations((prev) => [data, ...prev]);
      setCurrentConversation(data);
      setMessages([]);
      
      toast.success("Conversation created!");
      return data;
    } catch (error) {
      console.error("Error creating conversation:", error);
      toast.error("Failed to create conversation");
      return null;
    }
  };

  const selectConversation = async (id: string) => {
    const conversation = conversations.find((c) => c.id === id);
    if (!conversation) return;

    setCurrentConversation(conversation);
    await fetchMessages(id);
  };

  const sendMessage = async (content: string) => {
    if (!currentConversation || !session?.user?.id) return;

    try {
      // Add user message
      const { data: userMessage, error: userError } = await supabase
        .from("messages")
        .insert([
          {
            conversation_id: currentConversation.id,
            role: "user",
            content,
          },
        ])
        .select()
        .single();

      if (userError) throw userError;

      setMessages((prev) => [...prev, userMessage as Message]);

      // Simulate AI response (in a real app, this would call an AI service)
      const aiResponse = "This is a simulated AI response. In a production environment, this would be generated by your trained symbolic AI engine.";
      
      const { data: aiMessage, error: aiError } = await supabase
        .from("messages")
        .insert([
          {
            conversation_id: currentConversation.id,
            role: "assistant",
            content: aiResponse,
          },
        ])
        .select()
        .single();

      if (aiError) throw aiError;

      setMessages((prev) => [...prev, aiMessage as Message]);

      // Update conversation timestamp
      await supabase
        .from("conversations")
        .update({ updated_at: new Date().toISOString() })
        .eq("id", currentConversation.id);

    } catch (error) {
      console.error("Error sending message:", error);
      toast.error("Failed to send message");
    }
  };

  const deleteConversation = async (id: string) => {
    try {
      const { error } = await supabase
        .from("conversations")
        .delete()
        .eq("id", id);

      if (error) throw error;

      setConversations((prev) => prev.filter((c) => c.id !== id));
      
      if (currentConversation?.id === id) {
        setCurrentConversation(null);
        setMessages([]);
      }

      toast.success("Conversation deleted");
    } catch (error) {
      console.error("Error deleting conversation:", error);
      toast.error("Failed to delete conversation");
    }
  };

  const clearMessages = async () => {
    if (!currentConversation) return;

    try {
      const { error } = await supabase
        .from("messages")
        .delete()
        .eq("conversation_id", currentConversation.id);

      if (error) throw error;

      setMessages([]);
      toast.success("Messages cleared");
    } catch (error) {
      console.error("Error clearing messages:", error);
      toast.error("Failed to clear messages");
    }
  };

  const refreshConversations = async () => {
    await fetchConversations();
  };

  return (
    <ConversationContext.Provider
      value={{
        conversations,
        currentConversation,
        messages,
        isLoading,
        createConversation,
        selectConversation,
        sendMessage,
        deleteConversation,
        clearMessages,
        refreshConversations,
      }}
    >
      {children}
    </ConversationContext.Provider>
  );
};

export const useConversation = () => {
  const context = useContext(ConversationContext);
  if (context === undefined) {
    throw new Error("useConversation must be used within a ConversationProvider");
  }
  return context;
};
